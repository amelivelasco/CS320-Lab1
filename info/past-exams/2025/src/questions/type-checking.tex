% type-checking.tex

\question[5]

\newcommand{\amyInt}{\lstinline|Int|}
\newcommand{\amyBool}{\lstinline|Bool|}
\newcommand{\amyIf}{\lstinline|if|}
\newcommand{\amyThen}{\lstinline|then|}
\newcommand{\amyElse}{\lstinline|else|}
\newcommand{\amyTo}{\Rightarrow}
\newcommand{\amyPair}[2]{(#1, #2)}
\newcommand{\amyFst}{\lstinline|fst|}
\newcommand{\amySnd}{\lstinline|snd|}
\newcommand{\amyList}{\lstinline|List|}
\newcommand{\amyNil}{\lstinline|Nil()|}
\newcommand{\amyCons}{\lstinline|Cons|}

Consider the following type system for a programming language. The language
contains integers, Booleans, functions, and pairs.

Pairs \(\amyPair{\cdot}{\cdot}\) and functions \(\cdot \amyTo \cdot\) are
distinct binary type constructors.

  {
    \addtolength{\jot}{1em}
    \begin{gather*}
      % integers
      \AxiomC{\(n\) is an integer value}
      \RightLabel{Int}
      \UnaryInfC{\(\Gamma \vdash n : \amyInt\)}
      \DisplayProof \\
      % add mul
      \AxiomC{\(\Gamma \vdash e_1 : \amyInt\)}
      \AxiomC{\(\Gamma \vdash e_2 : \amyInt\)}
      \RightLabel{Add}
      \BinaryInfC{\(\Gamma \vdash e_1 + e_2 : \amyInt\)}
      \DisplayProof
      % \quad
      % \AxiomC{\(\Gamma \vdash e_1 : \amyInt\)}
      % \AxiomC{\(\Gamma \vdash e_2 : \amyInt\)}
      % \RightLabel{Mul}
      % \BinaryInfC{\(\Gamma \vdash e_1 * e_2 : \amyInt\)}
      % \DisplayProof 
      \\
      %
      % booleans
      \AxiomC{\(b\) is a Boolean value}
      \RightLabel{Bool}
      \UnaryInfC{\(\Gamma \vdash b : \amyBool\)}
      \DisplayProof \\
      % if
      \AxiomC{\(\Gamma \vdash e_1 : \amyBool\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau\)}
      \AxiomC{\(\Gamma \vdash e_3 : \tau\)}
      \RightLabel{If}
      \TrinaryInfC{\(\Gamma \vdash \amyIf~e_1~\amyThen~e_2~\amyElse~e_3 : \tau\)}
      \DisplayProof \\
      % predicates
      \AxiomC{\(\Gamma \vdash e_1 : \tau\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau\)}
      \RightLabel{Eq}
      \BinaryInfC{\(\Gamma \vdash e_1 == e_2 : \amyBool\)}
      \DisplayProof \quad
      \AxiomC{\(\Gamma \vdash e_1 : \amyInt\)}
      \AxiomC{\(\Gamma \vdash e_2 : \amyInt\)}
      \RightLabel{Lt}
      \BinaryInfC{\(\Gamma \vdash e_1 < e_2 : \amyBool\)}
      \DisplayProof \\
      % function
      \AxiomC{\(\Gamma, x : \tau_1 \vdash e : \tau_2\)}
      \RightLabel{Fun}
      \UnaryInfC{\(\Gamma \vdash (x : \tau_1) \amyTo e : \tau_1 \amyTo \tau_2\)}
      \DisplayProof \quad
      \AxiomC{\(\Gamma \vdash e_1 : \tau_1 \amyTo \tau_2\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau_1\)}
      \RightLabel{App}
      \BinaryInfC{\(\Gamma \vdash e_1~e_2 : \tau_2\)}
      \DisplayProof \\
      % pair
      \AxiomC{\(\Gamma \vdash e_1 : \tau_1\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau_2\)}
      \RightLabel{Pair}
      \BinaryInfC{\(\Gamma \vdash \amyPair{e_1}{e_2} : \amyPair{\tau_1}{\tau_2}\)}
      \DisplayProof \\
      % projections
      \AxiomC{\(\Gamma \vdash e : \amyPair{\tau_1}{\tau_2}\)}
      \RightLabel{Fst}
      \UnaryInfC{\(\Gamma \vdash \amyFst(e) : \tau_1\)}
      \DisplayProof \quad
      \AxiomC{\(\Gamma \vdash e : \amyPair{\tau_1}{\tau_2}\)}
      \RightLabel{Snd}
      \UnaryInfC{\(\Gamma \vdash \amySnd(e) : \tau_2\)}
      \DisplayProof \\
      % lists
      % \AxiomC{\phantom{\(\Gamma \vdash e_2\)}}
      % \RightLabel{Nil}
      % \UnaryInfC{\(\Gamma \vdash \amyNil : \amyList[\tau]\)}
      % \DisplayProof \quad
      % \AxiomC{\(\Gamma \vdash e_1 : \tau\)}
      % \AxiomC{\(\Gamma \vdash e_2 : \amyList[\tau]\)}
      % \RightLabel{Cons}
      % \BinaryInfC{\(\Gamma \vdash \amyCons(e_1, e_2) : \amyList[\tau]\)}
      % \DisplayProof
    \end{gather*}
  }
%%%% actual questions

\pagebreak

\begin{parts}
  % given a term, which of the following constraints hold in every valid
  % assignment to type variables
  \part \withpoints{2} Consider the term \(t\) below, with type variables \(\tau_1, \tau_2,
  \ldots, \tau_5\) ascribing subterms of \(t\) as shown:
  \begin{gather*}
    ((\lstinline|x| : \tau_1) \amyTo (\lstinline|y| : \tau_2) \amyTo
    (\amyIf ~(\amyFst(x): \tau_3)~ \amyThen~ \amySnd(x)~ \amyElse~ 1 + \amySnd(x)): \tau_4) : \tau_5
  \end{gather*}
  %
  Which of the following statements are true about assignments to the type
  variables such that \(t\) is well-typed?
  \begin{subparts}
    \subpart \withpoints{0.5} In every valid assignment, \(\tau_1 = \amyPair{\amyInt}{\amyBool}\): \falseChoice
    \subpart \withpoints{0.5} In every valid assignment, \(\tau_3 = \amyBool\): \trueChoice
    \subpart \withpoints{0.5} There is a valid assignment where \(\tau_2 = \amyInt\): \trueChoice
    \subpart \withpoints{0.5} In every valid assignment, \(\tau_5 = (\tau_1 \amyTo \tau_2 \amyTo \tau_4)\): \trueChoice
  \end{subparts}
  %
  % given a term, which of the following types apply to it
  \part \withpoints{1} Which of the following types \(\tau\) given below apply to the term
  \(t\) above, i.e. there is a derivation of \(\vdash t : \tau\)?
  %
  \begin{randomizechoices}
    \choice \((\amyInt, \amyBool) \amyTo \amyBool \amyTo \amyInt\)
    \CorrectChoice \((\amyBool, \amyInt) \amyTo \amyInt \amyTo \amyInt\)
    \choice \(((\amyBool, \amyInt) \amyTo \amyBool) \amyTo \amyInt\)
    \choice \((\amyInt, \amyBool) \amyTo (\amyBool, \amyInt) \amyTo \amyInt\)
  \end{randomizechoices}
  %
  % which of the following type pairs are unifiable
  % \part For each of the following type pairs, indicate whether they are
  % unifiable, i.e. if there is an assignment to type variables such that the
  % types become equal. 
  % \begin{parts}
  %   \part \amyInt, \amyInt \\
  %   \begin{oneparchoices}
  %     \CorrectChoice Yes
  %     \choice No
  %   \end{oneparchoices}
  % \end{parts}
  %
  % unification order for a complete type inference
  \part \withpoints{2} Consider the following term \(r\):
  \begin{gather*}
    \lstinline|x| \amyTo \amyFst(x)(\amySnd(x)) + \amySnd(x)
  \end{gather*}
  where we assign type variables to the subterms as follows:
  \begin{gather*}
    \lstinline|x| : \tau_1 \quad
    \amyFst(\lstinline|x|) : \tau_2 \quad
    \amySnd(\lstinline|x|) : \tau_3 \\
    \amyFst(\lstinline|x|)(\amySnd(\lstinline|x|)) : \tau_4 \\
    \amyFst(x)(\amySnd(\lstinline|x|)) + \amySnd(\lstinline|x|) : \tau_5 \\
    \lstinline|x| \amyTo \amyFst(x)(\amySnd(\lstinline|x|)) + \amySnd(\lstinline|x|) : \tau_6
  \end{gather*}
  %
  The initial unification constraints for type checking \(r\) are:
  \begin{gather*}
    \tau_6 = \tau_1 \amyTo \tau_5 \\
    \tau_5 = \amyInt \\
    \tau_4 = \amyInt \\
    \tau_3 = \amyInt \\
    \tau_2 = \tau_3 \amyTo \tau_4 \\
    \tau_1 = \amyPair{\tau_3'}{\tau_3} \\
    \tau_1 = \amyPair{\tau_2}{\tau_2'}
  \end{gather*}
  for fresh type variables \(\tau_2' \text{ and } \tau_3'\). Note that \(=\) has
  lower precedence than the type constructors (\(\amyTo,
  \amyPair{\cdot}{\cdot}\)), so \(\tau_6 = \tau_1 \amyTo \tau_5\) is parsed as
  ``\(\tau_6\) equals \(\tau_1 \to \tau_5\)". 
  \pagebreak

  Consider the following possible set of constraints at different unification
  steps (\textbf{this page and next}). The current set of unsolved constraints
  is listed \emph{below the bar}. Whenever we substitute a type variable, we add
  the mapping to the list \emph{above the bar}.
  %
  \addtolength{\fboxsep}{2mm}
  \addtolength{\jot}{0.1em}
  %
  \allowdisplaybreaks
  \begin{gather*}
    \setChoice{Init}{
      \emptyset \\
      \hline
      \tau_6 = \tau_1 \amyTo \tau_5 \\
      \tau_5 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_2 = \tau_3 \amyTo \tau_4 \\
      \tau_1 = \amyPair{\tau_3'}{\tau_3} \\
      \tau_1 = \amyPair{\tau_2}{\tau_2'}}
    \qquad
    \setChoice{1}{
      \tau_1 = (\amyInt, \amyInt) \\
      \tau_2 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \tau_6 = (\amyInt, \amyInt) \amyTo \amyInt\\
      \tau_2' = \amyInt \\
      \tau_3' = \amyInt \amyTo \amyInt \\
      \hline
      \emptyset
    }
    \\
    \setChoice{2}{
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_2 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \amyPair{\tau_3'}{\amyInt} \amyTo \amyInt \\
      \amyPair{\tau_3'}{\amyInt} = \amyPair{\amyInt}{\tau_2'}}
    \quad
    \setChoice{3}{
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \tau_1 \amyTo \amyInt \\
      \tau_2 = \amyInt \\
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_1 = \amyPair{\tau_2}{\tau_2'}}
    \quad
    \setChoice{4}{
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \amyPair{\tau_3'}{\amyInt} \amyTo \amyInt \\
      \tau_3' = \amyInt \amyTo \amyInt \\
      \amyInt = \tau_2'}
    \\
    \setChoice{5}{
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \amyPair{\tau_3'}{\amyInt} \amyTo \amyInt \\
      \amyPair{\tau_3'}{\amyInt} = \amyPair{\amyInt \amyTo \amyInt}{\tau_2'}}
    \qquad
    \setChoice{6}{
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \tau_1 \amyTo \amyInt \\
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_1 = \amyPair{\tau_2}{\tau_2'}}
    \\
    \setChoice{7}{
      \tau_1 = (\amyInt \amyTo \amyInt, \amyInt) \\
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \tau_6 = (\amyInt \amyTo \amyInt, \amyInt) \amyTo \amyInt\\
      \tau_2' = \amyInt \\
      \tau_3' = \amyInt \amyTo \amyInt \\
      \hline
      \emptyset
    }
    \quad
    \setChoice{8}{
      \tau_1 = (\amyInt \amyTo \amyInt, \amyInt) \\
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \tau_2' = \amyInt \\
      \tau_3' = \amyInt \amyTo \amyInt \\
      \hline
      \tau_6 = \amyPair{\amyInt \amyTo \amyInt}{\amyInt} \amyTo \amyInt}
    \\
    \setChoice{9}{
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_2 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \amyPair{\tau_3'}{\amyInt} \amyTo \amyInt \\
      \tau_3' = \amyInt \\
      \amyInt = \tau_2'}
    \quad
    \setChoice{10}{
      \tau_2 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \tau_1 \amyTo \amyInt \\
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_1 = \amyPair{\amyInt}{\tau_2'}}
    \quad
    \setChoice{11}{
      \tau_1 = (\amyInt, \amyInt) \\
      \tau_2 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \tau_2' = \amyInt \\
      \tau_3' = \amyInt \\
      \hline
      \tau_6 = \amyPair{\amyInt}{\amyInt} \amyTo \amyInt}
    \\
    \setChoice{12}{
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_2 = \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \amyPair{\tau_3'}{\amyInt} \amyTo \amyInt \\
      \amyInt = \amyInt \\
      \tau_3' = \tau_2'}
    \quad
    \setChoice{13}{
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \tau_1 \amyTo \amyInt \\
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_1 = \amyPair{\amyInt \amyTo \amyInt}{\tau_2'}}
    \quad
    \setChoice{14}{
      \tau_1 = \amyPair{\tau_3'}{\amyInt} \\
      \tau_2 = \amyInt \amyTo \amyInt \\
      \tau_3 = \amyInt \\
      \tau_4 = \amyInt \\
      \tau_5 = \amyInt \\
      \hline
      \tau_6 = \amyPair{\tau_3'}{\amyInt} \amyTo \amyInt \\
      \amyInt = \amyInt \\
      \tau_3' = \tau_2'}
  \end{gather*}
  %%% orders

  Circle an order of unification steps that leads to a correct and complete type
  inference for \(r\), i.e. ending with assignment of all type variables.
  \begin{randomizechoices}
    \CorrectChoice \textbf{Init, 6, 13, 5, 4, 8, 7}
    % slightly incorrect
    \choice \textbf{Init, 3, 10, 9, 11, 7}
    \choice \textbf{Init, 3, 10, 12, 11, 1}
    \choice \textbf{Init, 6, 13, 5, 14, 11, 1}
    % absolute nonsense
    \choice \textbf{Init, 3, 13, 5, 4, 8, 7}
    \choice \textbf{Init, 3, 10, 5, 4, 8, 1}
    \choice \textbf{Init, 6, 10, 9, 4, 8, 7}
    \choice \textbf{Init, 6, 10, 12, 11, 1}
  \end{randomizechoices}
  %%%% unfortunately the unification here takes like 10 steps.
  % \begin{gather*}
  %   \lstinline|l| \amyTo \lstinline|map|(\lstinline|l|, \lstinline|x| \amyTo \amyFst(\lstinline|x|) + \amySnd(\lstinline|x|))
  % \end{gather*}
  % %
  % where \(\lstinline|map|\) has type \(\forall \tau, \pi. \; \amyList[\tau]
  % \amyTo (\tau \amyTo \pi) \amyTo \amyList[\pi]\). We assign type variables to
  % the subterms as follows:
  % %
  % \begin{gather*}
  %   \lstinline|l| : \tau_1 \quad
  %   \lstinline|x| : \tau_2 \\
  %   \amyFst(\lstinline|x|) : \tau_3 \quad
  %   \amySnd(\lstinline|x|) : \tau_4 \\
  %   \amyFst(\lstinline|x|) + \amySnd(\lstinline|x|) : \tau_5 \\
  %   \lstinline|x| \amyTo \amyFst(\lstinline|x|) + \amySnd(\lstinline|x|) : \tau_6 \\
  %   \lstinline|map|(\lstinline|l|, \lstinline|x| \amyTo \amyFst(\lstinline|x|) + \amySnd(\lstinline|x|)) : \tau_7 \\
  %   \lstinline|l| \amyTo \lstinline|map|(\lstinline|l|, \lstinline|x| \amyTo \amyFst(\lstinline|x|) + \amySnd(\lstinline|x|)) : \tau_8
  % \end{gather*}
\end{parts}




