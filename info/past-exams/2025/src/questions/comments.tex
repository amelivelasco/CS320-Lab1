% comments.tex

\question[5]

Consider a simple language with variables (alphanumeric strings starting with a
letter), assignments (\lstinline|=|), equality (\lstinline|==|), conditionals
(\lstinline|if then else|), single-line comments (\lstinline|// ...|), and block
comments (\lstinline|/* ... */|). 
%

We wish to write a lexer for this language, by defining each of the following
tokens (in the given priority order):
\begin{equation*}
  \lstinline|IF|, \lstinline|THEN|, \lstinline|ELSE|, \lstinline|EQ|, \lstinline|ASSIGN|,
  \lstinline|LPAREN|, \lstinline|RPAREN|, \lstinline|ID|, \lstinline|INT|, \lstinline|LINESKIP|, 
  \lstinline|BLOCKSKIP|, \lstinline|WS|
\end{equation*}
%
The following example strings must be tokenized as given below. \lstinline|\n|
is a single character, representing a newline.
%
\begin{center}
  \begin{tabular}{c  c}
    String & Token Stream \\
    \hline
    \lstinline|x=1| & \lstinline|ID ASSIGN INT| \\
    \lstinline|if then else| & \lstinline|IF WS THEN WS ELSE| \\
    \lstinline|(x == 1)| & \lstinline|LPAREN ID WS EQ WS INT RPAREN| \\
    \lstinline|===| & \lstinline|EQ ASSIGN| \\
    \lstinline|if // comment if| & \lstinline|IF WS LINESKIP| \\
    \lstinline|// comment \n if| & \lstinline|LINESKIP WS IF| \\
    \lstinline|x ==/* comment */5| & \lstinline|ID WS EQ BLOCKSKIP INT| \\
    \lstinline|/* comment // other */ 5| & \lstinline|BLOCKSKIP WS INT| \\
    \lstinline|/* comment /* other */ */| & \emph{Lexing error} \\
  \end{tabular}
\end{center}
%
The lexer must enforce that block comments cannot be nested, i.e., a block
comment start \lstinline|/*| must not appear inside another block comment.

The lexing priority follows longest match rule and the priority of tokens as
given. You may assume \(\Sigma\) is the total alphabet, \(A\) is the set of
English letters (a-z, A-Z), and \(D\) is the set of digits (0-9).

For each of the tokens below, fill in the blank, choosing \textbf{one} regular
expression or non-deterministic finite automaton (NFA) (\textbf{next page}) that
represents the words to be matched by the token. \lstinline|WS|
(accepting spaces, tabs, and newlines) is defined.

\newcommand{\blankLength}{15ex}
\newcommand{\answerBlank}[1]{
  \ifprintanswers
    \textcolor{red}{#1}
  \else
    \underline{\hspace{\blankLength}}
  \fi
}

\begin{parts}
  \part \withpoints{0.4} \lstinline|IF|: \answerBlank{A}
  \part \withpoints{0.4} \lstinline|THEN|: \answerBlank{B}
  \part \withpoints{0.4} \lstinline|ELSE|: \answerBlank{P}
  \part \withpoints{0.4} \lstinline|EQ|: \answerBlank{I}
  \part \withpoints{0.4} \lstinline|ASSIGN|: \answerBlank{H}
  \part \withpoints{0.4} \lstinline|LPAREN|: \answerBlank{M}
  \part \withpoints{0.4} \lstinline|RPAREN|: \answerBlank{L}
  \part \withpoints{0.6} \lstinline|ID|: \answerBlank{N}
  \part \withpoints{0.4} \lstinline|INT|: \answerBlank{K}
  \part \withpoints{0.6} \lstinline|LINESKIP|: \answerBlank{G}
  \part \withpoints{0.6} \lstinline|BLOCKSKIP|: \answerBlank{E}
  \part \lstinline|WS|: \((``\lstinline|\s|" \mid ``\lstinline|\t|" \mid ``\lstinline|\n|")^+\)
\end{parts}

\pagebreak

We use the following notation for regular expressions and sets, where \(e_1\)
and \(e_2\) are regular expressions, and \(a, b, \) and \(c\) are characters in
the alphabet:
\begin{enumerate}
  \item \(e_1 e_2\) is the concatenation of \(e_1\) and \(e_2\).
  \item \(e_1 \mid e_2\) is the union or disjunction of \(e_1\) and \(e_2\).
  \item \(e^*\) represents zero or more repetitions of \(e\). \(e^+\) is one or
  more repetitions of \(e\).
  \item Characters in the alphabet are written with quotes for clarity, e.g.
  \(``a"\). A string of characters, e.g. \(``abc"\) represents the concatenation
  of characters, i.e., \(``a" ``b" ``c"\).
  \item A finite set of characters represents the disjunction of its elements,
  e.g. \(\{a, b, c\} = ``a" \mid ``b" \mid ``c"\).
  \item The binary operations union (\(\cup\)), intersection (\(\cap\)), and
  set difference (\(\setminus\)) are interpreted as usual on sets of characters.
\end{enumerate}
%
\vspace{-0.5em}
% choices
{
  \addtolength{\jot}{1.25em}
  % local automata settings
  \tikzset{accepting/.append style={double distance=1mm}}
  \tikzset{every state/.style={inner sep = 0, minimum size = 0.8cm}, initial text = {}}
  \tikzset{node distance=1.4cm}
  %%
\allowdisplaybreaks
\begin{gather*}
  \lexChoice{A}{``\lstinline|if|"}
  \quad
  \lexChoice{B}{``\lstinline|then|"}
  \quad
  \lexChoice{C}{``\lstinline|===|"}
  \quad
  \lexChoice{D}{
    \begin{tikzpicture}[initial text = {}, node distance=0.8cm]
      \node (0) [state, initial] {};
      \node (1) [state, accepting, right=of 0] {};
      \node (2) [state, accepting, right=of 1] {};
      %
      \draw[-latex] (0) -> node[above] {``\lstinline|=|"} (1);
      \draw[-latex] (1) -> node[above] {``\lstinline|=|"} (2);
    \end{tikzpicture}
  }
  \\
  \lexChoice{E}{
    \begin{tikzpicture}
      \node (0) [state, initial] {};
      \node (1) [state, right of = 0] {};
      \node (2) [state, right of = 1] {};
      \node (3) [state, right of = 2] {};
      \node (4) [state, accepting, right of = 3] {};
      \node (5) [state, below of = 2] {};
      %
      \draw[-latex] (0) -> node[above] {``\lstinline|/|"} (1);
      \draw[-latex] (1) -> node[above] {``\lstinline|*|"} (2);
      \draw[-latex] (2) -> node[above] {``\lstinline|*|"} (3);
      \draw[-latex] (3) -> node[above] {``\lstinline|/|"} (4);
      %
      \draw[-latex, loop above] (2) to node[above] {\(\Sigma \setminus \{``\lstinline|/|"\}\)} (2);
      \draw[-latex, bend right] (2) to node[left] {``\lstinline|/|"} (5);
      \draw[-latex, bend right] (5) to node[right] {\(\Sigma \setminus \{``\lstinline|*|"\}\)} (2);
    \end{tikzpicture}
  }
  \quad
  \lexChoice{F}{
    ``\lstinline|/*|"~ (\Sigma \setminus \{``\lstinline|/|"\})^* ~``\lstinline|*/|"
  }
  \\
  \lexChoice{G}{
    ``\lstinline|//|"~ (\Sigma \setminus \{``\lstinline|\\n|"\})^* \\
  }
  \quad
  \lexChoice{H}{
    \begin{tikzpicture}
      \node (0) [state, initial] {};
      \node (1) [state, accepting, right=of 0] {};
      \node (2) [state, right=of 1] {};
      %
      \draw[-latex] (0) -> node[above] {``\lstinline|=|"} (1);
      \draw[-latex] (1) -> node[above] {``\lstinline|=|"} (2);
    \end{tikzpicture}
  }
  \\
  \lexChoice{I}{
    \begin{tikzpicture}[initial text = {}, node distance=0.8cm]
      \node (0) [state, initial] {};
      \node (1) [state, right=of 0] {};
      \node (2) [state, accepting, right=of 1] {};
      %
      \draw[-latex] (0) -> node[above] {``\lstinline|=|"} (1);
      \draw[-latex] (1) -> node[above] {``\lstinline|=|"} (2);
    \end{tikzpicture}
  }
  \quad
  \lexChoice{J}{(A \cup D)^*}
  \quad
  \lexChoice{K}{D^+}
  \quad
  \lexChoice{L}{``\lstinline|)|"}
  \quad
  \lexChoice{M}{``\lstinline|(|"}
  \\
  \lexChoice{N}{A (A \cup D)^*}
  \quad
  \lexChoice{O}{
    \begin{tikzpicture}
      \node (0) [state, initial] {};
      \node (1) [state, right=of 0] {};
      \node (2) [state, accepting, right=of 1] {};
      \node (3) [state, right=of 2] {};
      %
      \draw[-latex] (0) -> node[above] {``\lstinline|/|"} (1);
      \draw[-latex] (1) -> node[above] {``\lstinline|/|"} (2);
      \draw[-latex] (2) -> node[above] {``\lstinline|\\n|"} (3);
      %
      \draw[-latex, loop above] (2) to node[above] {\(\Sigma\)} (2);
    \end{tikzpicture}
  }
  \\
  \lexChoice{P}{
    \begin{tikzpicture}
      \node (0) [state, initial] {};
      \node (1) [state, above right=of 0] {};
      \node (2) [state, right=of 1] {};
      \node (3) [state, right=of 2] {};
      \node (4) [state, accepting, right=of 3] {};
      %
      \node (5) [state, below right=of 0] {};
      \node (6) [state, right=of 5] {};
      \node (7) [state, right=of 6] {};
      \node (8) [state, right=of 7] {};
      %
      \draw[-latex] (0) -> node[above left] {``\lstinline|e|"} (1);
      \draw[-latex] (1) -> node[above] {``\lstinline|l|"} (2);
      \draw[-latex] (2) -> node[above] {``\lstinline|s|"} (3);
      \draw[-latex] (3) -> node[above] {``\lstinline|e|"} (4);
      %
      \draw[-latex] (0) -> node[below left] {``\lstinline|t|"} (5);
      \draw[-latex] (5) -> node[below] {``\lstinline|h|"} (6);
      \draw[-latex] (6) -> node[below] {``\lstinline|e|"} (7);
      \draw[-latex] (7) -> node[below] {``\lstinline|n|"} (8);
    \end{tikzpicture}
  }
\end{gather*}
}
% \begin{solutionorbox}
%   \begin{align*}
%     \lstinline|IF| &::= \lstinline|if| \\
%     \lstinline|THEN| &::= \lstinline|then| \\
%     \lstinline|ELSE| &::= \lstinline|else| \\
%     \lstinline|EQ| &::= \lstinline|==| \\
%     \lstinline|ASSIGN| &::= \lstinline|=| \\
%     \lstinline|LPAREN| &::= \lstinline|(| \\
%     \lstinline|RPAREN| &::= \lstinline|)| \\
%     \lstinline|ID| &::= A(A \mid D)^* \\
%     \lstinline|INT| &::= D^+ \\
%     \lstinline|SKIP| &::= \lstinline|//| (\Sigma \setminus \{\lstinline|\\n|\})^* \\
%                     & \quad \mid \lstinline|/*|~ ((\Sigma \setminus \{\lstinline|/|\}) ~|~ (\lstinline|/| (\Sigma \setminus \{\lstinline|*|\})))^* ~\lstinline|*/| \\
%   \end{align*}

%   The comment tokens say:
%   \begin{enumerate}
%     \item single-line: after \lstinline|//|, anything except a newline
%     \item block: between \lstinline|/* ... */|, anything except a slash
%     \lstinline|/|, or a slash followed by anything but a star \lstinline|*|.
%   \end{enumerate}

%   The lexer would fail to tokenize and throw an error if the input contains a
%   nested block comment.
  
% \end{solutionorbox}

