% ll1-table.tex

\question[5]

For the grammar defined in Question~\ref{q:ll1-transform}, produce an equivalent
LL(1) grammar. You do not need to show the parsing table or otherwise prove that
the new grammar is LL(1). \\

  \SetTotalWidth
  \begin{solutionorbox}[\fill]
    %
    \begin{align*}
      S &::= Expr ~\eof\\
      Expr &::= SimpleExpr~ Expr' \\
      Expr' &::= \epsilon \mid Match \\
      SimpleExpr &::= \lstinline{var} \mid Cons \mid (Expr) \\
      Cons &::= \lstinline{id} (ExprList) \\
      Match &::= \lstinline{match}~CaseList
    \end{align*}
    %
    Removing common prefixes from \(NExprList\):
    %
    \begin{align*}
      ExprList &::= \epsilon \mid NExprList \\
      NExprList &::= Expr~NExprList' \\
      NExprList' &::= \epsilon \mid ~,~NExprList \\
    \end{align*}
    %
    Removing common prefixes from \(CaseList\) and adjusting for \(Match\)
    priority:
    %
    \begin{align*}
      CaseList &::= \lstinline|case| ~SimpleExpr ~\lstinline|=>| ~SimpleExpr ~MaybeMatch\\
      MaybeMatch &::= \epsilon \mid CaseList \mid Match
    \end{align*}

    \textcolor{red}{2 points for ExprList, and 3 points for CaseList. If they eliminate common prefix from Case, then 1 point for that.}
  \end{solutionorbox}

%%%% old
% For the LL(1) grammar constructed in Question~\ref{q:ll1-transform}: 

% \begin{enumerate}
%   \item Compute \(\nullable\) for each non-terminal in the grammar.
%   \begin{EnvFullwidth}
%     \begin{solutionorbox}
%       The solution will vary with your chosen grammar. Based on our solution, with
%       numbered rules:
%       % the grammar, for reference
%       \begin{align}
%         Expr &::= SimpleExpr~ Expr' \mid (Expr) \\
%         Expr' &::= \epsilon \mid Match \\
%         SimpleExpr &::= \lstinline{var} \mid Cons \\
%         Cons &::= \lstinline{word} (ExprList) \\
%         Match &::= \lstinline{match}~CaseList \\
%         ExprList &::= \epsilon \mid NExprList \\
%         NExprList &::= Expr~NExprList' \\
%         NExprList' &::= \epsilon \mid ~,~NExprList \\
%         CaseList &::= \lstinline|case| ~SimpleExpr ~\lstinline|=>| ~SimpleExpr ~MaybeMatch\\
%         MaybeMatch &::= \epsilon \mid CaseList \mid Match
%       \end{align}

%       \begin{align*}
%         \nullable(Expr) &= false \\
%         \nullable(Expr') &= true \\
%         \nullable(SimpleExpr) &= false\\
%         \nullable(Cons) &= false \\
%         \nullable(Match) &= false \\
%         \nullable(ExprList) &= true \\
%         \nullable(NExprList) &= false \\
%         \nullable(NExprList') &= true \\
%         \nullable(CaseList) &= false \\
%         \nullable(MaybeMatch) &= true 
%       \end{align*}
%     \end{solutionorbox}
%   \end{EnvFullwidth}
%   \item Compute the \(\first\) sets for each non-terminal in the grammar.
%   \begin{EnvFullwidth}
%     \begin{solutionorbox}
%       The constraints for the \(\first\) sets are (marked by which rule they come from):
%       \begin{align*}
%         \{(\} &\subseteq \first(Expr) \tag{1} \\
%         \first(SimpleExpr) &\subseteq \first(Expr) \tag{1} \\
%         %
%         \first(Match) &\subseteq \first(Expr') \tag{2} \\
%         %
%         \{\lstinline|var|\} &\subseteq \first(SimpleExpr) \tag{3} \\
%         \first(Cons) &\subseteq \first(SimpleExpr) \tag{3} \\
%         %
%         \{\lstinline|word|\} &\subseteq \first(Cons) \tag{4} \\
%         \{\lstinline|match|\} &\subseteq \first(Match) \tag{5} \\
%         \first(NExprList) &\subseteq \first(ExprList) \tag{6} \\
%         \first(Expr) &\subseteq \first(NExprList) \tag{7} \\
%         \{,\} &\subseteq \first(NExprList') \tag{8} \\
%         \{\lstinline|case|\} &\subseteq \first(CaseList) \tag{9} \\
%         %
%         \first(CaseList) &\subseteq \first(MaybeMatch) \tag{10} \\
%         \first(Match) &\subseteq \first(MaybeMatch) \tag{10} \\
%       \end{align*}
%       %
%       which can be solved to get:
%       \begin{align*}
%         \first(Expr) &= \{(, \lstinline|var|, \lstinline|word|\} \\
%         \first(Expr') &= \{\lstinline|match|\} \\
%         \first(SimpleExpr) &= \{\lstinline|var|, \lstinline|word|\}\\
%         \first(Cons) &= \{\lstinline|word|\} \\
%         \first(Match) &= \{\lstinline|match|\} \\
%         \first(ExprList) &= \{(, \lstinline|var|, \lstinline|word|\} \\
%         \first(NExprList) &= \{(, \lstinline|var|, \lstinline|word|\} \\
%         \first(NExprList') &= \{,\} \\
%         \first(CaseList) &= \{\lstinline|case|\} \\
%         \first(MaybeMatch) &= \{\lstinline|match|, \lstinline|case|\} 
%       \end{align*}
%     \end{solutionorbox}
%   \end{EnvFullwidth}
%   \item Compute the \(\follow\) sets for each non-terminal in the grammar.
%   \item Use this information to construct the LL(1) parsing table for the grammar.
%   \item Use the LL(1) parsing table to parse the following string, showing
%   intermediate steps:
%   \begin{center}
% \begin{lstlisting}
% x match
%   case Nil() => x
%   case Cons(w, ws) => ws
% \end{lstlisting}
%   \end{center}

% \end{enumerate}
