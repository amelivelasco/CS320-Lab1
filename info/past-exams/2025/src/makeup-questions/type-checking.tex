% type-checking.tex

\question[5]

\newcommand{\amyInt}{\lstinline|Int|}
\newcommand{\amyBool}{\lstinline|Bool|}
\newcommand{\amyIf}{\lstinline|if|}
\newcommand{\amyThen}{\lstinline|then|}
\newcommand{\amyElse}{\lstinline|else|}
\newcommand{\amyTo}{\Rightarrow}
\newcommand{\amyPair}[2]{(#1, #2)}
\newcommand{\amyFst}{\lstinline|fst|}
\newcommand{\amySnd}{\lstinline|snd|}
\newcommand{\amyList}{\lstinline|List|}
\newcommand{\amyNil}{\lstinline|Nil()|}
\newcommand{\amyCons}{\lstinline|Cons|}

Consider the following type system for a programming language. The language
contains integers, Booleans, functions, and pairs.

Pairs \(\amyPair{\cdot}{\cdot}\) and functions \(\cdot \amyTo \cdot\) are
distinct binary type constructors.

  {
    \addtolength{\jot}{1em}
    \begin{gather*}
      % integers
      \AxiomC{\(n\) is an integer value}
      \RightLabel{Int}
      \UnaryInfC{\(\Gamma \vdash n : \amyInt\)}
      \DisplayProof \\
      % add mul
      \AxiomC{\(\Gamma \vdash e_1 : \amyInt\)}
      \AxiomC{\(\Gamma \vdash e_2 : \amyInt\)}
      \RightLabel{Add}
      \BinaryInfC{\(\Gamma \vdash e_1 + e_2 : \amyInt\)}
      \DisplayProof
      % \quad
      % \AxiomC{\(\Gamma \vdash e_1 : \amyInt\)}
      % \AxiomC{\(\Gamma \vdash e_2 : \amyInt\)}
      % \RightLabel{Mul}
      % \BinaryInfC{\(\Gamma \vdash e_1 * e_2 : \amyInt\)}
      % \DisplayProof 
      \\
      %
      % booleans
      \AxiomC{\(b\) is a Boolean value}
      \RightLabel{Bool}
      \UnaryInfC{\(\Gamma \vdash b : \amyBool\)}
      \DisplayProof \\
      % if
      \AxiomC{\(\Gamma \vdash e_1 : \amyBool\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau\)}
      \AxiomC{\(\Gamma \vdash e_3 : \tau\)}
      \RightLabel{If}
      \TrinaryInfC{\(\Gamma \vdash \amyIf~e_1~\amyThen~e_2~\amyElse~e_3 : \tau\)}
      \DisplayProof \\
      % predicates
      \AxiomC{\(\Gamma \vdash e_1 : \tau\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau\)}
      \RightLabel{Eq}
      \BinaryInfC{\(\Gamma \vdash e_1 == e_2 : \amyBool\)}
      \DisplayProof \quad
      \AxiomC{\(\Gamma \vdash e_1 : \amyInt\)}
      \AxiomC{\(\Gamma \vdash e_2 : \amyInt\)}
      \RightLabel{Lt}
      \BinaryInfC{\(\Gamma \vdash e_1 < e_2 : \amyBool\)}
      \DisplayProof \\
      % function
      \AxiomC{\(\Gamma, x : \tau_1 \vdash e : \tau_2\)}
      \RightLabel{Fun}
      \UnaryInfC{\(\Gamma \vdash (x : \tau_1) \amyTo e : \tau_1 \amyTo \tau_2\)}
      \DisplayProof \quad
      \AxiomC{\(\Gamma \vdash e_1 : \tau_1 \amyTo \tau_2\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau_1\)}
      \RightLabel{App}
      \BinaryInfC{\(\Gamma \vdash e_1~e_2 : \tau_2\)}
      \DisplayProof \\
      % pair
      \AxiomC{\(\Gamma \vdash e_1 : \tau_1\)}
      \AxiomC{\(\Gamma \vdash e_2 : \tau_2\)}
      \RightLabel{Pair}
      \BinaryInfC{\(\Gamma \vdash \amyPair{e_1}{e_2} : \amyPair{\tau_1}{\tau_2}\)}
      \DisplayProof \\
      % projections
      \AxiomC{\(\Gamma \vdash e : \amyPair{\tau_1}{\tau_2}\)}
      \RightLabel{Fst}
      \UnaryInfC{\(\Gamma \vdash \amyFst(e) : \tau_1\)}
      \DisplayProof \quad
      \AxiomC{\(\Gamma \vdash e : \amyPair{\tau_1}{\tau_2}\)}
      \RightLabel{Snd}
      \UnaryInfC{\(\Gamma \vdash \amySnd(e) : \tau_2\)}
      \DisplayProof \\
      % lists
      % \AxiomC{\phantom{\(\Gamma \vdash e_2\)}}
      % \RightLabel{Nil}
      % \UnaryInfC{\(\Gamma \vdash \amyNil : \amyList[\tau]\)}
      % \DisplayProof \quad
      % \AxiomC{\(\Gamma \vdash e_1 : \tau\)}
      % \AxiomC{\(\Gamma \vdash e_2 : \amyList[\tau]\)}
      % \RightLabel{Cons}
      % \BinaryInfC{\(\Gamma \vdash \amyCons(e_1, e_2) : \amyList[\tau]\)}
      % \DisplayProof
    \end{gather*}
  }
%%%% actual questions

\pagebreak

\begin{parts}
  % given a term, which of the following constraints hold in every valid
  % assignment to type variables
  \part \withpoints{2} Consider the term \(t\) below, with type variables \(\tau_z, \tau_x,
  \tau_y, \tau_l, \tau_r, \tau_{fx}\), and \(\tau_{sy}\) ascribing subterms of \(t\) as shown:
  \begin{gather*}
    (\lstinline|z| : \tau_z) \amyTo
    (((\lstinline|x| : \tau_x) \amyTo \amyFst(\lstinline|x|): \tau_{fx}, \lstinline|z|): \tau_l)
    ==
    ((\lstinline|z|, (\lstinline|y| : \tau_y) \amyTo \amySnd(\lstinline|y|): \tau_{sy}): \tau_r)
  \end{gather*}
  %
  Which of the following statements are true about assignments to the type
  variables such that \(t\) is well-typed?
  \begin{subparts}
    \subpart \withpoints{0.5} In every valid assignment, \(\tau_l = \tau_r\): \trueChoice
    \subpart \withpoints{0.5} In every valid assignment, \(\tau_l = \amyBool\): \falseChoice
    \subpart \withpoints{0.5} There is a valid assignment where \(\tau_z = \amyInt\): \falseChoice
    \subpart \withpoints{0.5} There is a valid assignment where \(\tau_x = (\amyInt, \amyBool)\): \falseChoice
  \end{subparts}
  %
  % given a term, which of the following types apply to it
  \part \withpoints{1} Which of the following types \(\tau\) given below apply to the term
  \(t\) above, i.e. there is a derivation of \(\vdash t : \tau\)?
  %
  \begin{randomizechoices}
    \choice \((\amyBool, \amyInt) \amyTo \amyBool\)
    \CorrectChoice \(((\amyInt, \amyInt) \amyTo \amyInt) \amyTo \amyBool\)
    \choice \((\amyBool \amyTo \amyBool) \amyTo \amyInt \amyTo \amyBool\)
    \choice \((\amyBool \amyTo (\amyBool, \amyBool)) \amyTo \amyBool\)
  \end{randomizechoices}
  %
  \part \withpoints{2} Consider the complete labelling of types of subterms of
  the term \(t\) below:
  \begin{gather*}
    t : \tau \\
    z : \tau_z \\
    (\lstinline|x| \amyTo \amyFst(\lstinline|x|), \lstinline|z|)
    ==
    (\lstinline|z|, \lstinline|y| \amyTo \amySnd(\lstinline|y|)) : \tau_{eq} \\
    (\lstinline|x| \amyTo \amyFst(\lstinline|x|), \lstinline|z|) : \tau_l \\
    \lstinline|x| \amyTo \amyFst(\lstinline|x|) : \tau_{funx} \\
    \lstinline|x| : \tau_x \\
    \amyFst(\lstinline|x|) : \tau_{fx} \\
    (\lstinline|z|, \lstinline|y| \amyTo \amySnd(\lstinline|y|)) : \tau_r \\
    \lstinline|y| \amyTo \amySnd(\lstinline|y|) : \tau_{funy} \\
    \lstinline|y| : \tau_y \\
    \amySnd(\lstinline|y|) : \tau_{sy}
  \end{gather*}
  %
  Given this labelling, 
  \begin{enumerate}
    \item Compute the set of initial type checking constraints for the term \(t\).
    \item Compute a general solution to the set of constraints to infer a
    general type for \(t\), using type unification.
  \end{enumerate}
  Use the provided space on the \textbf{next three pages} for your answer.
\end{parts}

\ifprintanswers
\pagebreak
\begin{solutionorbox}[\fill]
  Initial set of constraints:
  \begin{gather*}
    \tau = \tau_z \amyTo \tau_{eq} \\
    \tau_{eq} = \amyBool \\
    \tau_l = \tau_r \\
    \tau_l = \amyPair{\tau_{funx}}{\tau_z} \\
    \tau_{funx} = \tau_x \amyTo \tau_{fx} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_r = \amyPair{\tau_z}{\tau_{funy}} \\
    \tau_{funy} = \tau_y \amyTo \tau_{sy} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}}
  \end{gather*}
  %
  for fresh type variables \(\tau_{sx}\) and \(\tau_{fy}\).
  
  Step 1: substituting \(\tau_{eq}\) and \(\tau_l\). Equations above the lines
  are constraints we have substituted or solved. Equations below the line are 
  constraints we have not yet solved.
  %
  \begin{gather*}
    \tau_l = \tau_r \\
    \tau_{eq} = \amyBool \\
    \rule{0.5\textwidth}{0.4pt} \\
    \tau = \tau_z \amyTo \amyBool \\
    \tau_r = \amyPair{\tau_{funx}}{\tau_z} \\
    \tau_{funx} = \tau_x \amyTo \tau_{fx} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_r = \amyPair{\tau_z}{\tau_{funy}} \\
    \tau_{funy} = \tau_y \amyTo \tau_{sy} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}}
  \end{gather*}

  Step 2: substituting \(\tau_r\), \(\tau_x\), and \(\tau_y\).
  %
  \begin{gather*}
    \tau_l = \amyPair{\tau_{funx}}{\tau_z} \\
    \tau_{eq} = \amyBool \\
    \tau_r = \amyPair{\tau_{funx}}{\tau_z} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}} \\
    \rule{0.5\textwidth}{0.4pt} \\
    \tau = \tau_z \amyTo \amyBool \\
    \tau_{funx} = \amyPair{\tau_{fx}}{\tau_{sx}} \amyTo \tau_{fx} \\
    \amyPair{\tau_{funx}}{\tau_z} = \amyPair{\tau_z}{\tau_{funy}} \\
    \tau_{funy} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} 
  \end{gather*}

  Step 3: unification on \(\amyPair{\tau_{funx}}{\tau_z} = \amyPair{\tau_z}{\tau_{funy}}\):
  %
  \begin{gather*}
    \tau_l = \amyPair{\tau_{funx}}{\tau_z} \\
    \tau_{eq} = \amyBool \\
    \tau_r = \amyPair{\tau_{funx}}{\tau_z} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}} \\
    \rule{0.5\textwidth}{0.4pt} \\
    \tau = \tau_z \amyTo \amyBool \\
    \tau_{funx} = \amyPair{\tau_{fx}}{\tau_{sx}} \amyTo \tau_{fx} \\
    \tau_{funx} = \tau_{z} \\
    \tau_{z} = \tau_{funy} \\    
    \tau_{funy} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} 
  \end{gather*} 

  Step 4: substituting \(\tau_z\):
  %
  \begin{gather*}
    \tau_l = \amyPair{\tau_{funx}}{\tau_{funy}} \\
    \tau_{eq} = \amyBool \\
    \tau_r = \amyPair{\tau_{funx}}{\tau_{funy}} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}} \\
    \tau_z = \tau_{funy} \\
    \rule{0.5\textwidth}{0.4pt} \\
    \tau = \tau_z \amyTo \amyBool \\
    \tau_{funx} = \amyPair{\tau_{fx}}{\tau_{sx}} \amyTo \tau_{fx} \\
    \tau_{funx} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\    
    \tau_{funy} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} 
  \end{gather*} 

  Step 5: substituting \(\tau_{funx}\) and \(\tau_{funy}\):
  %
  \begin{gather*}
    \tau_l = \amyPair{\tau_{funy}}{\tau_{funy}} \\
    \tau_{eq} = \amyBool \\
    \tau_r = \amyPair{\tau_{funy}}{\tau_{funy}} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}} \\
    \tau_z = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\
    \tau_{funx} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\
    \tau_{funy} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\
    \rule{0.5\textwidth}{0.4pt} \\
    \tau = (\amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy}) \amyTo \amyBool \\
    \amyPair{\tau_{fx}}{\tau_{sx}} \amyTo \tau_{fx} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy}
  \end{gather*} 

  Step 6: unification on remaining function and pair constraint:
  %
  \begin{gather*}
    \tau_l = \amyPair{\tau_{funy}}{\tau_{funy}} \\
    \tau_{eq} = \amyBool \\
    \tau_r = \amyPair{\tau_{funy}}{\tau_{funy}} \\
    \tau_x = \amyPair{\tau_{fx}}{\tau_{sx}} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{sy}} \\
    \tau_z = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\
    \tau_{funx} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\
    \tau_{funy} = \amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy} \\
    \rule{0.5\textwidth}{0.4pt} \\
    \tau = (\amyPair{\tau_{fy}}{\tau_{sy}} \amyTo \tau_{sy}) \amyTo \amyBool \\
    \tau_{fx} = \tau_{fy} \\
    \tau_{sx} = \tau_{sy} \\
    \tau_{fx} = \tau_{sy} 
  \end{gather*} 
  
  Step 7: substituting remaining equalities:
  %
  \begin{gather*}
    \tau_l = \amyPair{\tau_{funy}}{\tau_{funy}} \\
    \tau_{eq} = \amyBool \\
    \tau_r = \amyPair{\tau_{funy}}{\tau_{funy}} \\
    \tau_x = \amyPair{\tau_{fy}}{\tau_{fy}} \\
    \tau_y = \amyPair{\tau_{fy}}{\tau_{fy}} \\
    \tau_z = \amyPair{\tau_{fy}}{\tau_{fy}} \amyTo \tau_{fy} \\
    \tau_{funx} = \amyPair{\tau_{fy}}{\tau_{fy}} \amyTo \tau_{fy} \\
    \tau_{funy} = \amyPair{\tau_{fy}}{\tau_{fy}} \amyTo \tau_{fy} \\
    \tau = (\amyPair{\tau_{fy}}{\tau_{fy}} \amyTo \tau_{fy}) \amyTo \amyBool \\
    \rule{0.5\textwidth}{0.4pt} \\
    \text{No constraints left}
  \end{gather*} 

  Giving the final general type \(\tau = (\amyPair{\tau_{fy}}{\tau_{fy}} \amyTo
  \tau_{fy}) \amyTo \amyBool\), for every possible value of the variable
  \(\tau_{fy}\).
  
\end{solutionorbox}
\fi

\answerPage
\answerPage
\answerPage

